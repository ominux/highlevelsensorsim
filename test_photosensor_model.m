%> @file test_photosensor_model.m
%> @brief This tesing routine is necessary for testing the correctness of the operation of photosensor and its noise performance.
%>
%> @author Mikhail V. Konnik
%> @date   17 January 2011
%>
%> @section raiom Radiometry and radiometric functions.
%> @subsection radiometry Radiometry and light field formation
%> Radiometry is the measurement of optical radiation, which is electromagnetic radiation within the frequency range between \f$3\times10^{11}\f$ and \f$3\times10^{16}\f$ Hz (\f$\lambda \in 0.01 .. 1000  \mu m\f$). Typical units encountered are Watt/\f$m^2\f$ and photons/s-steradian\cite{rpfaq}.@n
%> Photometry is the measurement of light, which is defined as electromagnetic radiation that is detectable by the human eye. It is restricted to the wavelength range from \f$\lambda \in 0.36 .. 0.83 \mu m\f$ \cite{rpfaq}. Photometry is radiometry that is weighted by the spectral response of the eye.
%>
%> @subsection lightsource Light sources
%> The light is generated by the source with known radiance and wavelength \f$\lambda\f$. Irradiance is known for the sensor in Watt/\f$m^2\f$ \cite{decusatishandbook}. There are two types of light sources: lambertian and isotropic\cite{ciephotometry}. Both terms mean \textit{the same in all directions} but they are not interchangeable.@n
%> @b Isotropic implies a spherical source that radiates the same in all directions, i.e., the intensity (W/sr) is the same in all directions.The best example is a globular tungsten lamp with a milky white diffuse envelope. A distant star can be considered an isotropic point source.@n
%> @b Lambertian refers to a flat radiating surface. It can be an active surface or a passive, reflective surface. Here the intensity falls off as the cosine of the observation angle with respect to the surface normal, that is Lambert's law\cite{lambert1760photometria}. The radiance (W/\f$m^2\f$-sr) is independent of direction.
%>
%> @subsection radiometryunits Radiometric units
%> Radiometric units can be divided into two conceptual areas: those having to do with power or energy, and those that are geometric in nature. @n
%> @b Energy is an SI derived unit, measured in joules (J). The recommended symbol for energy is \f$Q\f$. An acceptable alternate is W\cite{decusatishandbook}.@n
%> \textbf{Power} (radiant flux) is another SI derived unit. It is the rate of flow (derivative) of energy with respect to time, \f$dQ/dt\f$, and the unit is the watt (W). The recommended symbol for power is \f$\Phi\f$. An acceptable alternate is P.@n
%>  Now we incorporate power with the geometric quantities area and solid angle.@n
%> @b Irradiance (flux density) is another SI derived unit and is measured in W/\f$m^2\f$. Irradiance is power per unit area incident from all directions in a hemisphere onto a surface that coincides with the base of that hemisphere. The symbol for irradiance is E and the symbol for radiant exitance is \f$M\f$. Irradiance is the derivative of power with respect to area, \f$d\Phi/dA\f$. The integral of irradiance or radiant exitance over area is power.@n
%> @Radiance is the last SI derived unit we need and is measured in W/\f$m^2\f$-sr. Radiance is power per unit projected area per unit solid angle. The symbol is L. Radiance is the derivative of power with respect to solid angle and projected area, \f$d\Phi/d\omega dA cos(\theta)\f$, where \f$\theta\f$ is the angle between the surface normal and the specified direction. The integral of radiance over area and solid angle is power.@n
%> A great deal of confusion concerns the use and misuse of the term \textit{intensity}. Some use it for W/sr, some use it for W/\f$m^2\f$ and others use it for W/\f$m^2\f$-sr. It is quite clearly defined in the SI system, in the definition of the base unit of luminous intensity, the candela. For an extended discussion see Ref.\cite{gettingintense}.
clc
clear all
close all
warning off

addpath('sensors', 'propagation');


%%%%%%%%#### Section: selectable parameters

%%%%%%%%#### Subsection: Irradiance parameters
N  = 256;         % number of grid points in the observation plane, on photo sensor NxN pixels. %% changes size of spot: smaller number=smaller spot, larger number - larger spectral
M  = 256;

lambda = 550*10^(-9); % optical wavelength [m]
%%%%%%%%#### END Subsection: Irradiance parameters


%%%%%%%%## Subsection: General photosensor settings
%  	ccd.SensorType		= 'CCD';
	ccd.SensorType		= 'CMOS';

	ccd.pixel_size = [5*10^(-6), 5*10^(-6)] ;  %% pixels size, in [m], ROWxCOLUMN size

	ccd.t_I	  = 1*10^(-2); %%% exposure/integration time, [sec].

	ccd.QE_I          = 0.8;  %% quantum efficiency of the photo sensor.
	ccd.FillFactor    = 0.5;  %% Pixel Fill Factor for CMOS photo sensors.
	ccd.QuantumYield  = 1;  %% quantum yeild (number of electrons per one photon interaction). QuantumYield = 1 for visible light.
    
	ccd.FW_e  = 2*10^4; %% full well of the pixel (how many electrons can be stored in one pixel), [e]

	ccd.V_REF	      = 3.1; %%% Reference voltage to reset the sense node. [V] typically 3-10 V.

    ccd.flag.Venonlinearity = 0; %%%%% <-- ###### Gain non-linearity Subsection [CMOS ONLY!!!!]
		if (ccd.flag.Venonlinearity == 1)
			ccd.nonlinearity.A_SNratio = 0.05; %% in how many times should A_SF be increased due to non-linearity?
		end %%% if (ccd.flag.VVnonlinearity == 1)

	ccd.A_SN		= 5*10^(-6); %% Sense node gain, A_SN [V/e]

%%%%% <----- ### Start:: Source Follower Subsection
	ccd.A_SF		= 1; %%% Source follower gain, [V/V], lower means amplify the noise.

	ccd.flag.VVnonlinearity = 0; %%%%% <-- ###### Gain non-linearity Subsection [CMOS ONLY!!!!]
		if (ccd.flag.VVnonlinearity == 1)
			ccd.nonlinearity.A_SFratio = 1.05; %% signal gets lower
%  			ccd.nonlinearity.A_SFratio = 0.95; %% signal gets HIGHER
		end %%% if (ccd.flag.VVnonlinearity == 1)
%%%%% <----- ### END:: Source Follower Subsection


	ccd.A_CDS		= 1; %%% Correlated Double Sampling gain, [V/V], lower means amplify the noise.


%%%% <----- ### Start:: ADC Subsection
 	ccd.N_bits		 = 12; %% noise is more apparent on high Bits
    
    ccd.S_ADC_OFFSET = 0; %%% Offset of the ADC, in DN

	ccd.flag.ADCnonlinearity= 1; %%% turn the non-linea
		if (ccd.flag.ADCnonlinearity == 1)
			ccd.nonlinearity.ADCratio = 1.1; %% in how many times should A_ADC be decreased due to non-linearity?
		end %%% if (ccd.flag.ADCnonlinearity == 1)
%%%%% <-- ###### END:: ADC Subsection

%%%## END Subsection: General photosensor settings;



%%%%%%%%## Subsection: photosensor NOISE settings
ccd.flag.photonshotnoise	= 1;

ccd.flag.PRNU			= 1;
 	ccd.noise.FPN.model	= 'Janesick-Gaussian';
 	ccd.PRNU_factor		= 0.01;  %% PRNU factor in percent [typically about 1\% for CCD and up to 5% for CMOS];

    
%% Dark noises
ccd.flag.darkcurrent		= 1;
        	ccd.T			= 300; %% operating temperature, [K]
            ccd.DFM			= 1;  %% dark current figure of merit, [nA/cm^2]. %%%% For very poor sensors, add DFM
%  Increasing the DFM more than 10 results to (with the same exposure time of 10^-6):
%  Hence the DFM increases the standard deviation and does not affect the mean value.

ccd.flag.darkcurrent_Dshot	= 1;


ccd.flag.darkcurrent_DarkFPN_pixel = 1;
if (ccd.flag.darkcurrent_DarkFPN_pixel == 1)

    ccd.noise.FPN.DN	= 0.3; %% the dark current FPN quality factor, which is typically between 10\% and 40\% for CCD and CMOS sensors

 	ccd.noise.FPN.model	= 'Janesick-Gaussian';

%  	ccd.noise.FPN.model	= 'AR-ElGamal';
%  	ccd.noise.FPN.ar_elgamal= [1 0.5];

% 	ccd.noise.FPN.model	= 'Wald';
% 	ccd.noise.FPN.wald_parameter = 2; %% small parameters (w<1) produces estremely narrow distribution, large parameters (w>10) produces distribution with large tail.

%  	ccd.noise.FPN.model	= 'LogNormal'; %%% suitable for long exposures
%  	ccd.noise.FPN.lognorm_parameter = [0, 0.4]; %%first is lognorm_mu; second is lognorm_sigma.

end %%  if (ccd.flag.darkcurrent_DarkFPN_pixel == 1)




ccd.flag.darkcurrent_offsetFPN	= 1;
if (ccd.flag.darkcurrent_offsetFPN == 1)
	ccd.noise.FPN.model	= 'Janesick-Gaussian';
	ccd.DNcolumn 		= 0.0003;  %% percentage of (V_REF - V_SN)
end


ccd.flag.sourcefollowernoise	= 1;
if (ccd.flag.sourcefollowernoise== 1)
	ccd.noise.sf.t_s	= 10^(-6); %% is the CDS sample-to-sampling time [sec].
	ccd.noise.sf.f_c	= 10^6; %% flicker noise corner frequency $f_c$ in [Hz], where power spectrum of white and flicker noise are equal [Hz].
	ccd.f_clock_speed	= 20*10^(6); %%20 MHz data rate clocking speed.
	ccd.noise.sf.W_f	= 15*10^(-9); %% is the thermal white noise [\f$V/Hz^{1/2}\f$, typically \f$15 nV/Hz^{1/2}\f$ ]
	ccd.noise.sf.Delta_I	= 10^(-8); % [Amper] is the source follower current modulation induced by RTS [CMOS ONLY]
end %% if (ccd.flag.sourcefollowernoise == 1)


ccd.flag.sensenoderesetnoise	= 1; %%%<---- 
	ccd.snresetnoiseFactor	= 0.01;
%%%%%%%%## END Subsection: photosensor NOISE settings


%%%## Subsection: Sensor noises and signal visualisators
ccd.flag.plots.irradiance	= 1;
ccd.flag.plots.electrons	= 1;
ccd.flag.plots.volts		= 0;
ccd.flag.plots.DN		    = 0;
%%%## Subsection: Sensor noises and signal visualisators

%%% For testing and measurements only:
ccd.flag.writetotiff		= 0; %%% output of the image to TIFF file
ccd.flag.darkframe          = 0;
%%%%%%%%############### END Section: selectable parameters %%%%%%%%%%%%%%%%%%%%%%%%





if (ccd.flag.darkframe == 0)

%%%%%%%%#### Section: Illumination
amplitude_coeff = 0.1;

% Uin = amplitude_coeff*ones(N,M);

Uin = amplitude_coeff*ones(N).*prop_absorbing_window_supergaussian(N, 6, 0.4); %% input (source) optical field, possibly a complex matrix.
%%%%%%%%#### END Section: Illumination and propagation


	%%%%%%%%%%%% Visualisation subsection.
	if (ccd.flag.plots.irradiance == 1)
	Uin_irradiance = abs(Uin).^2; %% computing the Irradiance [W/m^2] of the input optical field Uin.
    
	figure, imagesc(Uin_irradiance), title('Irradiance map of the light field [W/m^2].'); %% Irradiance map of the optical field.
	figure, plot(Uin_irradiance(round(N/2),1:M)), title('profile of the Irradiance map of the light field [W/m^2].'), xlabel('Number of Pixel on the photo sensor'), ylabel('Irradiance, [W/m^2]');  %% the profile of the Irradiance map

    end %% if (ccd.flag.plots.irradiance
	%%%%%%%%%%%% Visualisation subsection.

else

    Uin = zeros(N);

end%% if (ccd.flag.darkframe == 1)


% break %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%











%%%%%%%%####### BEGIN::: Light registration with the model of the CCD/CMOS sensor

ccd = ccd_photosensor(Uin,lambda, ccd); %% here the Photon-to-electron conversion occurred.

%%%%%%%%########### END: Light registration with the model of the CCD/CMOS sensor











%%%%%%%%%%%% Visualisation subsection.
if (ccd.flag.plots.irradiance == 1)
figure, imagesc(ccd.Signal_CCD_photons), title('Signal from the photosensor in Photons.'), colorbar;
end

if (ccd.flag.plots.electrons == 1)
figure, imagesc(ccd.Signal_CCD_electrons), title('Signal from the photosensor in electrons.'), colorbar; %%
figure, imagesc(log10(abs(ccd.Signal_CCD_electrons))), title('Log-log Signal from the photosensor in electrons.'), colorbar;
end

if (ccd.flag.plots.volts == 1)
figure, imagesc(ccd.Signal_CCD_voltage), title('Signal from the photosensor in Volts.'), colorbar; %%
figure, imagesc(log10(abs(ccd.Signal_CCD_voltage))), title('Log-Log Signal from the photosensor in Volts.'), colorbar; %%
end

if (ccd.flag.plots.DN == 1)
figure, imagesc(ccd.Signal_CCD_DN), title('Signal from the photosensor in DN.'), colorbar; %%
figure, imagesc(log10(abs(ccd.Signal_CCD_DN))), title('Log-Log Signal from the photosensor in DN.'); %%
end
%%%%%%%%%%%% END Visualisation subsection.


%%%%%%%%%%####        Section: Write down the image to TIFF file
if (ccd.flag.writetotiff == 1)
tool_photosensor_image_output(ccd); %%% Write down files in TIFF FORMAT
end
%%%%%%%%%%####### END Section: Write down the image to TIFF file